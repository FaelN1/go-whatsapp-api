<#
.SYNOPSIS
Clean event log files generated by the application.

.DESCRIPTION
Deletes files under the event_logs directory matching a pattern and older than a given number of days.
Supports dry-run and keeping the latest N files per directory to avoid removing important recent files.

.PARAMETER Path
Path to the event logs directory. Default: ./event_logs

.PARAMETER Days
Remove files older than this many days. Default: 30

.PARAMETER KeepLatest
Keep the latest N files per directory (overrides age for those files). Default: 0 (disabled)

.PARAMETER Pattern
File name pattern to match. Default: *.json

.PARAMETER DryRun
If present, only list files that would be deleted.

.PARAMETER Recurse
Search directories recursively. Default: $true

.EXAMPLE
PowerShell (dry-run):
.
\scripts\windows\clean-eventlogs.ps1 -Path .\event_logs -Days 30 -DryRun

.EXAMPLE
From cmd.exe:
scripts\windows\clean-eventlogs.bat .\event_logs 30
#>
param(
    [string]$Path = "./event_logs",
    [int]$Days = 30,
    [int]$KeepLatest = 0,
    [string]$Pattern = "*.json",
    [switch]$DryRun,
    [switch]$Recurse = $true
)

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

$absPath = Resolve-Path -LiteralPath $Path -ErrorAction SilentlyContinue
if (-not $absPath) {
    Write-Error "Path '$Path' not found."; exit 2
}
$absPath = $absPath.ProviderPath

$now = Get-Date
$threshold = $now.AddDays(-$Days)

Write-Host "Cleaning event logs in: $absPath"
Write-Host "Age threshold: $Days days (before $($threshold.ToString('u')) )"
if ($KeepLatest -gt 0) { Write-Host "Keep latest $KeepLatest files per directory" }
if ($DryRun) { Write-Host "Mode: DRY RUN (no files will be deleted)" }

# Collect files
$files = Get-ChildItem -Path $absPath -Filter $Pattern -File -Recurse:$Recurse -ErrorAction SilentlyContinue
if (-not $files) { Write-Host "No files found matching pattern."; exit 0 }

$toDelete = @()

if ($KeepLatest -gt 0) {
    # Group by directory and exclude the newest $KeepLatest in each
    $groups = $files | Group-Object -Property DirectoryName
    foreach ($g in $groups) {
        $sorted = $g.Group | Sort-Object LastWriteTime -Descending
        $keep = $sorted | Select-Object -First $KeepLatest
        $candidates = $sorted | Where-Object { $keep -notcontains $_ }
        # Optionally filter by age
        $old = $candidates | Where-Object { $_.LastWriteTime -lt $threshold }
        $toDelete += $old
    }
} else {
    $toDelete = $files | Where-Object { $_.LastWriteTime -lt $threshold }
}

if (-not $toDelete -or $toDelete.Count -eq 0) {
    Write-Host "No files to delete after applying filters."
    exit 0
}

# Summary
$size = ($toDelete | Measure-Object -Property Length -Sum).Sum
Write-Host "Files found for deletion: $($toDelete.Count) â€” total size: $([Math]::Round($size/1MB, 2)) MB"

if ($DryRun) {
    Write-Host "--- DRY RUN: listing files ---"
    $toDelete | Sort-Object FullName | ForEach-Object { Write-Host $_.FullName "| LastWrite:" $_.LastWriteTime }
    exit 0
}

# Confirm
Write-Host "Proceed to delete $($toDelete.Count) files? (Y/N)"
$k = Read-Host
if ($k -ne 'Y' -and $k -ne 'y') {
    Write-Host "Aborted by user."; exit 0
}

# Delete
$deleted = 0
$errors = 0
foreach ($f in $toDelete) {
    try {
        Remove-Item -LiteralPath $f.FullName -Force -ErrorAction Stop
        $deleted++
    } catch {
        Write-Warning "Failed to delete $($f.FullName): $_"
        $errors++
    }
}

Write-Host "Deleted: $deleted files. Errors: $errors"
exit 0
